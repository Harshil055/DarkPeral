import { Octokit } from "@octokit/rest";

export interface GitHubFile {
  path: string;
  content: string;
}

export interface GitHubRepoInfo {
  owner: string;
  repo: string;
  branch?: string;
}

export class GitHubService {
  private octokit: Octokit;

  constructor(accessToken: string) {
    this.octokit = new Octokit({
      auth: accessToken,
    });
  }

  /**
   * Get authenticated user's GitHub username
   */
  async getAuthenticatedUser() {
    const { data } = await this.octokit.users.getAuthenticated();
    return data;
  }

  /**
   * Create a new repository
   */
  async createRepository(name: string, isPrivate: boolean = false, description?: string) {
    const { data } = await this.octokit.repos.createForAuthenticatedUser({
      name,
      private: isPrivate,
      description: description || `Generated by DarkPearl AI`,
      auto_init: true,
    });
    return data;
  }

  /**
   * Get repository information
   */
  async getRepository(owner: string, repo: string) {
    const { data } = await this.octokit.repos.get({
      owner,
      repo,
    });
    return data;
  }

  /**
   * List user's repositories
   */
  async listRepositories() {
    const { data } = await this.octokit.repos.listForAuthenticatedUser({
      sort: "updated",
      per_page: 100,
    });
    return data;
  }

  /**
   * Get the latest commit SHA of a branch
   */
  async getLatestCommitSha(owner: string, repo: string, branch: string = "main") {
    const { data } = await this.octokit.repos.getBranch({
      owner,
      repo,
      branch,
    });
    return data.commit.sha;
  }

  /**
   * Get tree SHA from a commit
   */
  async getTreeSha(owner: string, repo: string, commitSha: string) {
    const { data } = await this.octokit.git.getCommit({
      owner,
      repo,
      commit_sha: commitSha,
    });
    return data.tree.sha;
  }

  /**
   * Create a blob (file content)
   */
  async createBlob(owner: string, repo: string, content: string) {
    const { data } = await this.octokit.git.createBlob({
      owner,
      repo,
      content: Buffer.from(content).toString("base64"),
      encoding: "base64",
    });
    return data.sha;
  }

  /**
   * Create a tree with multiple files
   */
  async createTree(
    owner: string,
    repo: string,
    files: GitHubFile[],
    baseTreeSha?: string
  ) {
    const tree = await Promise.all(
      files.map(async (file) => {
        const blobSha = await this.createBlob(owner, repo, file.content);
        return {
          path: file.path,
          mode: "100644" as const,
          type: "blob" as const,
          sha: blobSha,
        };
      })
    );

    const { data } = await this.octokit.git.createTree({
      owner,
      repo,
      tree,
      base_tree: baseTreeSha,
    });

    return data.sha;
  }

  /**
   * Create a commit
   */
  async createCommit(
    owner: string,
    repo: string,
    message: string,
    treeSha: string,
    parentSha: string
  ) {
    const { data } = await this.octokit.git.createCommit({
      owner,
      repo,
      message,
      tree: treeSha,
      parents: [parentSha],
    });
    return data.sha;
  }

  /**
   * Update branch reference to point to a new commit
   */
  async updateBranchRef(owner: string, repo: string, branch: string, commitSha: string) {
    await this.octokit.git.updateRef({
      owner,
      repo,
      ref: `heads/${branch}`,
      sha: commitSha,
    });
  }

  /**
   * Push multiple files to a repository
   * This is the main function to push generated code
   */
  async pushFiles(
    owner: string,
    repo: string,
    files: GitHubFile[],
    commitMessage: string,
    branch: string = "main"
  ) {
    try {
      // Get the latest commit SHA
      const latestCommitSha = await this.getLatestCommitSha(owner, repo, branch);

      // Get the tree SHA from the latest commit
      const baseTreeSha = await this.getTreeSha(owner, repo, latestCommitSha);

      // Create a new tree with all the files
      const newTreeSha = await this.createTree(owner, repo, files, baseTreeSha);

      // Create a new commit
      const newCommitSha = await this.createCommit(
        owner,
        repo,
        commitMessage,
        newTreeSha,
        latestCommitSha
      );

      // Update the branch to point to the new commit
      await this.updateBranchRef(owner, repo, branch, newCommitSha);

      return {
        success: true,
        commitSha: newCommitSha,
        message: "Files pushed successfully",
      };
    } catch (error) {
      console.error("Error pushing files to GitHub:", error);
      throw error;
    }
  }

  /**
   * Check if repository exists
   */
  async repositoryExists(owner: string, repo: string): Promise<boolean> {
    try {
      await this.octokit.repos.get({
        owner,
        repo,
      });
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get file content from repository
   */
  async getFileContent(owner: string, repo: string, path: string, branch: string = "main") {
    try {
      const { data } = await this.octokit.repos.getContent({
        owner,
        repo,
        path,
        ref: branch,
      });

      if (Array.isArray(data)) {
        throw new Error("Path is a directory, not a file");
      }

      if (data.type !== "file") {
        throw new Error("Path is not a file");
      }

      // Decode base64 content
      const content = Buffer.from(data.content, "base64").toString("utf-8");
      return content;
    } catch (error) {
      console.error("Error getting file content:", error);
      throw error;
    }
  }
}

/**
 * Exchange GitHub OAuth code for access token
 */
export async function exchangeCodeForToken(code: string): Promise<string> {
  const clientId = process.env.GITHUB_CLIENT_ID;
  const clientSecret = process.env.GITHUB_CLIENT_SECRET;

  if (!clientId || !clientSecret) {
    throw new Error("GitHub OAuth credentials not configured");
  }

  const response = await fetch("https://github.com/login/oauth/access_token", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
    },
    body: JSON.stringify({
      client_id: clientId,
      client_secret: clientSecret,
      code,
    }),
  });

  const data = await response.json();

  if (data.error) {
    throw new Error(`GitHub OAuth error: ${data.error_description || data.error}`);
  }

  return data.access_token;
}

/**
 * Get GitHub OAuth authorization URL
 */
export function getGitHubAuthUrl(state: string): string {
  const clientId = process.env.GITHUB_CLIENT_ID;
  const callbackUrl = process.env.NEXT_PUBLIC_APP_URL
    ? `${process.env.NEXT_PUBLIC_APP_URL}/api/github/callback`
    : "http://localhost:3000/api/github/callback";

  if (!clientId) {
    throw new Error("GitHub Client ID not configured");
  }

  const params = new URLSearchParams({
    client_id: clientId,
    redirect_uri: callbackUrl,
    scope: "repo user",
    state,
  });

  return `https://github.com/login/oauth/authorize?${params.toString()}`;
}
